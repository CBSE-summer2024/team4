"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksvelte_app"] = self["webpackChunksvelte_app"] || []).push([["vendors-node_modules_svelte-spa-router_Router_svelte"],{

/***/ "./node_modules/svelte-spa-router/Router.svelte":
/*!******************************************************!*\
  !*** ./node_modules/svelte-spa-router/Router.svelte ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   link: () => (/* binding */ link),\n/* harmony export */   loc: () => (/* binding */ loc),\n/* harmony export */   location: () => (/* binding */ location),\n/* harmony export */   params: () => (/* binding */ params),\n/* harmony export */   pop: () => (/* binding */ pop),\n/* harmony export */   push: () => (/* binding */ push),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   restoreScroll: () => (/* binding */ restoreScroll),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\n/* harmony import */ var _wrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrap */ \"./node_modules/svelte-spa-router/wrap.js\");\n/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte */ \"webpack/sharing/consume/default/svelte/svelte\");\n/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(svelte__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! svelte/store */ \"./node_modules/svelte/store/index.mjs\");\n/* harmony import */ var regexparam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! regexparam */ \"./node_modules/regexparam/dist/index.mjs\");\n/* node_modules\\svelte-spa-router\\Router.svelte generated by Svelte v3.59.2 */\n\n\n\n\n\n\n\n\nfunction create_else_block(ctx) {\n\tlet switch_instance;\n\tlet switch_instance_anchor;\n\tlet current;\n\tconst switch_instance_spread_levels = [/*props*/ ctx[2]];\n\tvar switch_value = /*component*/ ctx[0];\n\n\tfunction switch_props(ctx) {\n\t\tlet switch_instance_props = {};\n\n\t\tfor (let i = 0; i < switch_instance_spread_levels.length; i += 1) {\n\t\t\tswitch_instance_props = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.assign)(switch_instance_props, switch_instance_spread_levels[i]);\n\t\t}\n\n\t\treturn { props: switch_instance_props };\n\t}\n\n\tif (switch_value) {\n\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t\tswitch_instance.$on(\"routeEvent\", /*routeEvent_handler_1*/ ctx[7]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\tswitch_instance_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, switch_instance_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tconst switch_instance_changes = (dirty & /*props*/ 4)\n\t\t\t? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_update)(switch_instance_spread_levels, [(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_object)(/*props*/ ctx[2])])\n\t\t\t: {};\n\n\t\t\tif (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {\n\t\t\t\tif (switch_instance) {\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\t\t\t\t\tconst old_component = switch_instance;\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t\t}\n\n\t\t\t\tif (switch_value) {\n\t\t\t\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t\t\t\t\tswitch_instance.$on(\"routeEvent\", /*routeEvent_handler_1*/ ctx[7]);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_instance = null;\n\t\t\t\t}\n\t\t\t} else if (switch_value) {\n\t\t\t\tswitch_instance.$set(switch_instance_changes);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(switch_instance_anchor);\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance, detaching);\n\t\t}\n\t};\n}\n\n// (260:0) {#if componentParams}\nfunction create_if_block(ctx) {\n\tlet switch_instance;\n\tlet switch_instance_anchor;\n\tlet current;\n\tconst switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];\n\tvar switch_value = /*component*/ ctx[0];\n\n\tfunction switch_props(ctx) {\n\t\tlet switch_instance_props = {};\n\n\t\tfor (let i = 0; i < switch_instance_spread_levels.length; i += 1) {\n\t\t\tswitch_instance_props = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.assign)(switch_instance_props, switch_instance_spread_levels[i]);\n\t\t}\n\n\t\treturn { props: switch_instance_props };\n\t}\n\n\tif (switch_value) {\n\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t\tswitch_instance.$on(\"routeEvent\", /*routeEvent_handler*/ ctx[6]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\tswitch_instance_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, switch_instance_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tconst switch_instance_changes = (dirty & /*componentParams, props*/ 6)\n\t\t\t? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_update)(switch_instance_spread_levels, [\n\t\t\t\t\tdirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },\n\t\t\t\t\tdirty & /*props*/ 4 && (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_object)(/*props*/ ctx[2])\n\t\t\t\t])\n\t\t\t: {};\n\n\t\t\tif (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {\n\t\t\t\tif (switch_instance) {\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\t\t\t\t\tconst old_component = switch_instance;\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t\t}\n\n\t\t\t\tif (switch_value) {\n\t\t\t\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t\t\t\t\tswitch_instance.$on(\"routeEvent\", /*routeEvent_handler*/ ctx[6]);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_instance = null;\n\t\t\t\t}\n\t\t\t} else if (switch_value) {\n\t\t\t\tswitch_instance.$set(switch_instance_changes);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(switch_instance_anchor);\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance, detaching);\n\t\t}\n\t};\n}\n\nfunction create_fragment(ctx) {\n\tlet current_block_type_index;\n\tlet if_block;\n\tlet if_block_anchor;\n\tlet current;\n\tconst if_block_creators = [create_if_block, create_else_block];\n\tconst if_blocks = [];\n\n\tfunction select_block_type(ctx, dirty) {\n\t\tif (/*componentParams*/ ctx[1]) return 0;\n\t\treturn 1;\n\t}\n\n\tcurrent_block_type_index = select_block_type(ctx, -1);\n\tif_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\n\treturn {\n\t\tc() {\n\t\t\tif_block.c();\n\t\t\tif_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif_blocks[current_block_type_index].m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, if_block_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tlet previous_block_index = current_block_type_index;\n\t\t\tcurrent_block_type_index = select_block_type(ctx, dirty);\n\n\t\t\tif (current_block_type_index === previous_block_index) {\n\t\t\t\tif_blocks[current_block_type_index].p(ctx, dirty);\n\t\t\t} else {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {\n\t\t\t\t\tif_blocks[previous_block_index] = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t\tif_block = if_blocks[current_block_type_index];\n\n\t\t\t\tif (!if_block) {\n\t\t\t\t\tif_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t} else {\n\t\t\t\t\tif_block.p(ctx, dirty);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);\n\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif_blocks[current_block_type_index].d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(if_block_anchor);\n\t\t}\n\t};\n}\n\nfunction wrap(component, userData, ...conditions) {\n\t// Use the new wrap method and show a deprecation warning\n\t// eslint-disable-next-line no-console\n\tconsole.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');\n\n\treturn (0,_wrap__WEBPACK_IMPORTED_MODULE_1__.wrap)({ component, userData, conditions });\n}\n\n/**\n * @typedef {Object} Location\n * @property {string} location - Location (page/view), for example `/book`\n * @property {string} [querystring] - Querystring from the hash, as a string not parsed\n */\n/**\n * Returns the current location from the hash.\n *\n * @returns {Location} Location object\n * @private\n */\nfunction getLocation() {\n\tconst hashPosition = window.location.href.indexOf('#/');\n\n\tlet location = hashPosition > -1\n\t? window.location.href.substr(hashPosition + 1)\n\t: '/';\n\n\t// Check if there's a querystring\n\tconst qsPosition = location.indexOf('?');\n\n\tlet querystring = '';\n\n\tif (qsPosition > -1) {\n\t\tquerystring = location.substr(qsPosition + 1);\n\t\tlocation = location.substr(0, qsPosition);\n\t}\n\n\treturn { location, querystring };\n}\n\nconst loc = (0,svelte_store__WEBPACK_IMPORTED_MODULE_3__.readable)(null, // eslint-disable-next-line prefer-arrow-callback\nfunction start(set) {\n\tset(getLocation());\n\n\tconst update = () => {\n\t\tset(getLocation());\n\t};\n\n\twindow.addEventListener('hashchange', update, false);\n\n\treturn function stop() {\n\t\twindow.removeEventListener('hashchange', update, false);\n\t};\n});\n\nconst location = (0,svelte_store__WEBPACK_IMPORTED_MODULE_3__.derived)(loc, $loc => $loc.location);\nconst querystring = (0,svelte_store__WEBPACK_IMPORTED_MODULE_3__.derived)(loc, $loc => $loc.querystring);\nconst params = (0,svelte_store__WEBPACK_IMPORTED_MODULE_3__.writable)(undefined);\n\nasync function push(location) {\n\tif (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {\n\t\tthrow Error('Invalid parameter location');\n\t}\n\n\t// Execute this code when the current call stack is complete\n\tawait (0,svelte__WEBPACK_IMPORTED_MODULE_2__.tick)();\n\n\t// Note: this will include scroll state in history even when restoreScrollState is false\n\thistory.replaceState(\n\t\t{\n\t\t\t...history.state,\n\t\t\t__svelte_spa_router_scrollX: window.scrollX,\n\t\t\t__svelte_spa_router_scrollY: window.scrollY\n\t\t},\n\t\tundefined\n\t);\n\n\twindow.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;\n}\n\nasync function pop() {\n\t// Execute this code when the current call stack is complete\n\tawait (0,svelte__WEBPACK_IMPORTED_MODULE_2__.tick)();\n\n\twindow.history.back();\n}\n\nasync function replace(location) {\n\tif (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {\n\t\tthrow Error('Invalid parameter location');\n\t}\n\n\t// Execute this code when the current call stack is complete\n\tawait (0,svelte__WEBPACK_IMPORTED_MODULE_2__.tick)();\n\n\tconst dest = (location.charAt(0) == '#' ? '' : '#') + location;\n\n\ttry {\n\t\tconst newState = { ...history.state };\n\t\tdelete newState['__svelte_spa_router_scrollX'];\n\t\tdelete newState['__svelte_spa_router_scrollY'];\n\t\twindow.history.replaceState(newState, undefined, dest);\n\t} catch(e) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn('Caught exception while replacing the current page. If you\\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');\n\t}\n\n\t// The method above doesn't trigger the hashchange event, so let's do that manually\n\twindow.dispatchEvent(new Event('hashchange'));\n}\n\nfunction link(node, opts) {\n\topts = linkOpts(opts);\n\n\t// Only apply to <a> tags\n\tif (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {\n\t\tthrow Error('Action \"link\" can only be used with <a> tags');\n\t}\n\n\tupdateLink(node, opts);\n\n\treturn {\n\t\tupdate(updated) {\n\t\t\tupdated = linkOpts(updated);\n\t\t\tupdateLink(node, updated);\n\t\t}\n\t};\n}\n\nfunction restoreScroll(state) {\n\t// If this exists, then this is a back navigation: restore the scroll position\n\tif (state) {\n\t\twindow.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);\n\t} else {\n\t\t// Otherwise this is a forward navigation: scroll to top\n\t\twindow.scrollTo(0, 0);\n\t}\n}\n\n// Internal function used by the link function\nfunction updateLink(node, opts) {\n\tlet href = opts.href || node.getAttribute('href');\n\n\t// Destination must start with '/' or '#/'\n\tif (href && href.charAt(0) == '/') {\n\t\t// Add # to the href attribute\n\t\thref = '#' + href;\n\t} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {\n\t\tthrow Error('Invalid value for \"href\" attribute: ' + href);\n\t}\n\n\tnode.setAttribute('href', href);\n\n\tnode.addEventListener('click', event => {\n\t\t// Prevent default anchor onclick behaviour\n\t\tevent.preventDefault();\n\n\t\tif (!opts.disabled) {\n\t\t\tscrollstateHistoryHandler(event.currentTarget.getAttribute('href'));\n\t\t}\n\t});\n}\n\n// Internal function that ensures the argument of the link action is always an object\nfunction linkOpts(val) {\n\tif (val && typeof val == 'string') {\n\t\treturn { href: val };\n\t} else {\n\t\treturn val || {};\n\t}\n}\n\n/**\n * The handler attached to an anchor tag responsible for updating the\n * current history state with the current scroll state\n *\n * @param {string} href - Destination\n */\nfunction scrollstateHistoryHandler(href) {\n\t// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that\n\thistory.replaceState(\n\t\t{\n\t\t\t...history.state,\n\t\t\t__svelte_spa_router_scrollX: window.scrollX,\n\t\t\t__svelte_spa_router_scrollY: window.scrollY\n\t\t},\n\t\tundefined\n\t);\n\n\t// This will force an update as desired, but this time our scroll state will be attached\n\twindow.location.hash = href;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { routes = {} } = $$props;\n\tlet { prefix = '' } = $$props;\n\tlet { restoreScrollState = false } = $$props;\n\n\t/**\n * Container for a route: path, component\n */\n\tclass RouteItem {\n\t\t/**\n * Initializes the object and creates a regular expression from the path, using regexparam.\n *\n * @param {string} path - Path to the route (must start with '/' or '*')\n * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped\n */\n\t\tconstructor(path, component) {\n\t\t\tif (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {\n\t\t\t\tthrow Error('Invalid component object');\n\t\t\t}\n\n\t\t\t// Path must be a regular or expression, or a string starting with '/' or '*'\n\t\t\tif (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {\n\t\t\t\tthrow Error('Invalid value for \"path\" argument - strings must start with / or *');\n\t\t\t}\n\n\t\t\tconst { pattern, keys } = (0,regexparam__WEBPACK_IMPORTED_MODULE_4__.parse)(path);\n\t\t\tthis.path = path;\n\n\t\t\t// Check if the component is wrapped and we have conditions\n\t\t\tif (typeof component == 'object' && component._sveltesparouter === true) {\n\t\t\t\tthis.component = component.component;\n\t\t\t\tthis.conditions = component.conditions || [];\n\t\t\t\tthis.userData = component.userData;\n\t\t\t\tthis.props = component.props || {};\n\t\t\t} else {\n\t\t\t\t// Convert the component to a function that returns a Promise, to normalize it\n\t\t\t\tthis.component = () => Promise.resolve(component);\n\n\t\t\t\tthis.conditions = [];\n\t\t\t\tthis.props = {};\n\t\t\t}\n\n\t\t\tthis._pattern = pattern;\n\t\t\tthis._keys = keys;\n\t\t}\n\n\t\t/**\n * Checks if `path` matches the current route.\n * If there's a match, will return the list of parameters from the URL (if any).\n * In case of no match, the method will return `null`.\n *\n * @param {string} path - Path to test\n * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.\n */\n\t\tmatch(path) {\n\t\t\t// If there's a prefix, check if it matches the start of the path.\n\t\t\t// If not, bail early, else remove it before we run the matching.\n\t\t\tif (prefix) {\n\t\t\t\tif (typeof prefix == 'string') {\n\t\t\t\t\tif (path.startsWith(prefix)) {\n\t\t\t\t\t\tpath = path.substr(prefix.length) || '/';\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (prefix instanceof RegExp) {\n\t\t\t\t\tconst match = path.match(prefix);\n\n\t\t\t\t\tif (match && match[0]) {\n\t\t\t\t\t\tpath = path.substr(match[0].length) || '/';\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if the pattern matches\n\t\t\tconst matches = this._pattern.exec(path);\n\n\t\t\tif (matches === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// If the input was a regular expression, this._keys would be false, so return matches as is\n\t\t\tif (this._keys === false) {\n\t\t\t\treturn matches;\n\t\t\t}\n\n\t\t\tconst out = {};\n\t\t\tlet i = 0;\n\n\t\t\twhile (i < this._keys.length) {\n\t\t\t\t// In the match parameters, URL-decode all values\n\t\t\t\ttry {\n\t\t\t\t\tout[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tout[this._keys[i]] = null;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\n\t\t/**\n * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events\n * @typedef {Object} RouteDetail\n * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)\n * @property {string} location - Location path\n * @property {string} querystring - Querystring from the hash\n * @property {object} [userData] - Custom data passed by the user\n * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)\n * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)\n */\n\t\t/**\n * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.\n * \n * @param {RouteDetail} detail - Route detail\n * @returns {boolean} Returns true if all the conditions succeeded\n */\n\t\tasync checkConditions(detail) {\n\t\t\tfor (let i = 0; i < this.conditions.length; i++) {\n\t\t\t\tif (!await this.conditions[i](detail)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Set up all routes\n\tconst routesList = [];\n\n\tif (routes instanceof Map) {\n\t\t// If it's a map, iterate on it right away\n\t\troutes.forEach((route, path) => {\n\t\t\troutesList.push(new RouteItem(path, route));\n\t\t});\n\t} else {\n\t\t// We have an object, so iterate on its own properties\n\t\tObject.keys(routes).forEach(path => {\n\t\t\troutesList.push(new RouteItem(path, routes[path]));\n\t\t});\n\t}\n\n\t// Props for the component to render\n\tlet component = null;\n\n\tlet componentParams = null;\n\tlet props = {};\n\n\t// Event dispatcher from Svelte\n\tconst dispatch = (0,svelte__WEBPACK_IMPORTED_MODULE_2__.createEventDispatcher)();\n\n\t// Just like dispatch, but executes on the next iteration of the event loop\n\tasync function dispatchNextTick(name, detail) {\n\t\t// Execute this code when the current call stack is complete\n\t\tawait (0,svelte__WEBPACK_IMPORTED_MODULE_2__.tick)();\n\n\t\tdispatch(name, detail);\n\t}\n\n\t// If this is set, then that means we have popped into this var the state of our last scroll position\n\tlet previousScrollState = null;\n\n\tlet popStateChanged = null;\n\n\tif (restoreScrollState) {\n\t\tpopStateChanged = event => {\n\t\t\t// If this event was from our history.replaceState, event.state will contain\n\t\t\t// our scroll history. Otherwise, event.state will be null (like on forward\n\t\t\t// navigation)\n\t\t\tif (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {\n\t\t\t\tpreviousScrollState = event.state;\n\t\t\t} else {\n\t\t\t\tpreviousScrollState = null;\n\t\t\t}\n\t\t};\n\n\t\t// This is removed in the destroy() invocation below\n\t\twindow.addEventListener('popstate', popStateChanged);\n\n\t\t(0,svelte__WEBPACK_IMPORTED_MODULE_2__.afterUpdate)(() => {\n\t\t\trestoreScroll(previousScrollState);\n\t\t});\n\t}\n\n\t// Always have the latest value of loc\n\tlet lastLoc = null;\n\n\t// Current object of the component loaded\n\tlet componentObj = null;\n\n\t// Handle hash change events\n\t// Listen to changes in the $loc store and update the page\n\t// Do not use the $: syntax because it gets triggered by too many things\n\tconst unsubscribeLoc = loc.subscribe(async newLoc => {\n\t\tlastLoc = newLoc;\n\n\t\t// Find a route matching the location\n\t\tlet i = 0;\n\n\t\twhile (i < routesList.length) {\n\t\t\tconst match = routesList[i].match(newLoc.location);\n\n\t\t\tif (!match) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst detail = {\n\t\t\t\troute: routesList[i].path,\n\t\t\t\tlocation: newLoc.location,\n\t\t\t\tquerystring: newLoc.querystring,\n\t\t\t\tuserData: routesList[i].userData,\n\t\t\t\tparams: match && typeof match == 'object' && Object.keys(match).length\n\t\t\t\t? match\n\t\t\t\t: null\n\t\t\t};\n\n\t\t\t// Check if the route can be loaded - if all conditions succeed\n\t\t\tif (!await routesList[i].checkConditions(detail)) {\n\t\t\t\t// Don't display anything\n\t\t\t\t$$invalidate(0, component = null);\n\n\t\t\t\tcomponentObj = null;\n\n\t\t\t\t// Trigger an event to notify the user, then exit\n\t\t\t\tdispatchNextTick('conditionsFailed', detail);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Trigger an event to alert that we're loading the route\n\t\t\t// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n\t\t\tdispatchNextTick('routeLoading', Object.assign({}, detail));\n\n\t\t\t// If there's a component to show while we're loading the route, display it\n\t\t\tconst obj = routesList[i].component;\n\n\t\t\t// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted\n\t\t\tif (componentObj != obj) {\n\t\t\t\tif (obj.loading) {\n\t\t\t\t\t$$invalidate(0, component = obj.loading);\n\t\t\t\t\tcomponentObj = obj;\n\t\t\t\t\t$$invalidate(1, componentParams = obj.loadingParams);\n\t\t\t\t\t$$invalidate(2, props = {});\n\n\t\t\t\t\t// Trigger the routeLoaded event for the loading component\n\t\t\t\t\t// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)\n\t\t\t\t\tdispatchNextTick('routeLoaded', Object.assign({}, detail, {\n\t\t\t\t\t\tcomponent,\n\t\t\t\t\t\tname: component.name,\n\t\t\t\t\t\tparams: componentParams\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\t$$invalidate(0, component = null);\n\t\t\t\t\tcomponentObj = null;\n\t\t\t\t}\n\n\t\t\t\t// Invoke the Promise\n\t\t\t\tconst loaded = await obj();\n\n\t\t\t\t// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile\n\t\t\t\tif (newLoc != lastLoc) {\n\t\t\t\t\t// Don't update the component, just exit\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If there is a \"default\" property, which is used by async routes, then pick that\n\t\t\t\t$$invalidate(0, component = loaded && loaded.default || loaded);\n\n\t\t\t\tcomponentObj = obj;\n\t\t\t}\n\n\t\t\t// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`\n\t\t\t// Of course, this assumes that developers always add a \"params\" prop when they are expecting parameters\n\t\t\tif (match && typeof match == 'object' && Object.keys(match).length) {\n\t\t\t\t$$invalidate(1, componentParams = match);\n\t\t\t} else {\n\t\t\t\t$$invalidate(1, componentParams = null);\n\t\t\t}\n\n\t\t\t// Set static props, if any\n\t\t\t$$invalidate(2, props = routesList[i].props);\n\n\t\t\t// Dispatch the routeLoaded event then exit\n\t\t\t// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n\t\t\tdispatchNextTick('routeLoaded', Object.assign({}, detail, {\n\t\t\t\tcomponent,\n\t\t\t\tname: component.name,\n\t\t\t\tparams: componentParams\n\t\t\t})).then(() => {\n\t\t\t\tparams.set(componentParams);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If we're still here, there was no match, so show the empty component\n\t\t$$invalidate(0, component = null);\n\n\t\tcomponentObj = null;\n\t\tparams.set(undefined);\n\t});\n\n\t(0,svelte__WEBPACK_IMPORTED_MODULE_2__.onDestroy)(() => {\n\t\tunsubscribeLoc();\n\t\tpopStateChanged && window.removeEventListener('popstate', popStateChanged);\n\t});\n\n\tfunction routeEvent_handler(event) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);\n\t}\n\n\tfunction routeEvent_handler_1(event) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);\n\t}\n\n\t$$self.$$set = $$props => {\n\t\tif ('routes' in $$props) $$invalidate(3, routes = $$props.routes);\n\t\tif ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);\n\t\tif ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);\n\t};\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*restoreScrollState*/ 32) {\n\t\t\t// Update history.scrollRestoration depending on restoreScrollState\n\t\t\t$: history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';\n\t\t}\n\t};\n\n\treturn [\n\t\tcomponent,\n\t\tcomponentParams,\n\t\tprops,\n\t\troutes,\n\t\tprefix,\n\t\trestoreScrollState,\n\t\trouteEvent_handler,\n\t\trouteEvent_handler_1\n\t];\n}\n\nclass Router extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {\n\t\t\troutes: 3,\n\t\t\tprefix: 4,\n\t\t\trestoreScrollState: 5\n\t\t});\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);\n\n\n\n//# sourceURL=webpack://svelte-app/./node_modules/svelte-spa-router/Router.svelte?");

/***/ }),

/***/ "./node_modules/svelte-spa-router/wrap.js":
/*!************************************************!*\
  !*** ./node_modules/svelte-spa-router/wrap.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @typedef {Object} WrappedComponent Object returned by the `wrap` method\n * @property {SvelteComponent} component - Component to load (this is always asynchronous)\n * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate\n * @property {Object} [props] - Optional dictionary of static props\n * @property {Object} [userData] - Optional user data dictionary\n * @property {bool} _sveltesparouter - Internal flag; always set to true\n */\n\n/**\n * @callback AsyncSvelteComponent\n * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component\n */\n\n/**\n * @callback RoutePrecondition\n * @param {RouteDetail} detail - Route detail object\n * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)\n */\n\n/**\n * @typedef {Object} WrapOptions Options object for the call to `wrap`\n * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)\n * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)\n * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component\n * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)\n * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`\n * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.\n * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order\n */\n\n/**\n * Wraps a component to enable multiple capabilities:\n * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.\n * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)\n * 3. Adding static props that are passed to the component\n * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)\n * \n * @param {WrapOptions} args - Arguments object\n * @returns {WrappedComponent} Wrapped component\n */\nfunction wrap(args) {\n    if (!args) {\n        throw Error('Parameter args is required')\n    }\n\n    // We need to have one and only one of component and asyncComponent\n    // This does a \"XNOR\"\n    if (!args.component == !args.asyncComponent) {\n        throw Error('One and only one of component and asyncComponent is required')\n    }\n\n    // If the component is not async, wrap it into a function returning a Promise\n    if (args.component) {\n        args.asyncComponent = () => Promise.resolve(args.component)\n    }\n\n    // Parameter asyncComponent and each item of conditions must be functions\n    if (typeof args.asyncComponent != 'function') {\n        throw Error('Parameter asyncComponent must be a function')\n    }\n    if (args.conditions) {\n        // Ensure it's an array\n        if (!Array.isArray(args.conditions)) {\n            args.conditions = [args.conditions]\n        }\n        for (let i = 0; i < args.conditions.length; i++) {\n            if (!args.conditions[i] || typeof args.conditions[i] != 'function') {\n                throw Error('Invalid parameter conditions[' + i + ']')\n            }\n        }\n    }\n\n    // Check if we have a placeholder component\n    if (args.loadingComponent) {\n        args.asyncComponent.loading = args.loadingComponent\n        args.asyncComponent.loadingParams = args.loadingParams || undefined\n    }\n\n    // Returns an object that contains all the functions to execute too\n    // The _sveltesparouter flag is to confirm the object was created by this router\n    const obj = {\n        component: args.asyncComponent,\n        userData: args.userData,\n        conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,\n        props: (args.props && Object.keys(args.props).length) ? args.props : {},\n        _sveltesparouter: true\n    }\n\n    return obj\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wrap);\n\n\n//# sourceURL=webpack://svelte-app/./node_modules/svelte-spa-router/wrap.js?");

/***/ }),

/***/ "./node_modules/regexparam/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/regexparam/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inject: () => (/* binding */ inject),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nfunction parse(str, loose) {\n\tif (str instanceof RegExp) return { keys:false, pattern:str };\n\tvar c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');\n\tarr[0] || arr.shift();\n\n\twhile (tmp = arr.shift()) {\n\t\tc = tmp[0];\n\t\tif (c === '*') {\n\t\t\tkeys.push('wild');\n\t\t\tpattern += '/(.*)';\n\t\t} else if (c === ':') {\n\t\t\to = tmp.indexOf('?', 1);\n\t\t\text = tmp.indexOf('.', 1);\n\t\t\tkeys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );\n\t\t\tpattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';\n\t\t\tif (!!~ext) pattern += (!!~o ? '?' : '') + '\\\\' + tmp.substring(ext);\n\t\t} else {\n\t\t\tpattern += '/' + tmp;\n\t\t}\n\t}\n\n\treturn {\n\t\tkeys: keys,\n\t\tpattern: new RegExp('^' + pattern + (loose ? '(?=$|\\/)' : '\\/?$'), 'i')\n\t};\n}\n\nvar RGX = /*#__PURE__*/ /(\\/|^)([:*][^/]*?)(\\?)?(?=[/.]|$)/g;\n\n// error if key missing?\nfunction inject(route, values) {\n\treturn route.replace(RGX, (x, lead, key, optional) => {\n\t\tx = values[key=='*' ? 'wild' : key.substring(1)];\n\t\treturn x ? '/'+x : (optional || key=='*') ? '' : '/' + key;\n\t});\n}\n\n\n//# sourceURL=webpack://svelte-app/./node_modules/regexparam/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/svelte/store/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/svelte/store/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   derived: () => (/* binding */ derived),\n/* harmony export */   get: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value),\n/* harmony export */   readable: () => (/* binding */ readable),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   writable: () => (/* binding */ writable)\n/* harmony export */ });\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ \"./node_modules/svelte/internal/index.mjs\");\n\n\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier} [start]\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=} start\n */\nfunction writable(value, start = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0 && stop) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let started = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        started = true;\n        sync();\n        return function stop() {\n            (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);\n            cleanup();\n            // We need to set this to false because callbacks can still happen despite having unsubscribed:\n            // Callbacks might already be placed in the queue which doesn't know it should no longer\n            // invoke this derived store.\n            started = false;\n        };\n    });\n}\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @param store - store to make readonly\n */\nfunction readonly(store) {\n    return {\n        subscribe: store.subscribe.bind(store)\n    };\n}\n\n\n\n\n//# sourceURL=webpack://svelte-app/./node_modules/svelte/store/index.mjs?");

/***/ })

}]);